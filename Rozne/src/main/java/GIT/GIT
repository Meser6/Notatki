--------------- GIT ---------------

W Gicie są 3 przestrzenie robocze:
    - Working tree - tu znajdują się pliki które nie są śledzone, sledzone ale ze zmianami nie
              zaakceptowanymi do commita
    - Index - tu są wszytskie pliki ktore sa gotowe do commitu
              jeśli plik jest dodany (git add) ale wprowadzimy w nim zmiany to wersja ze zmianami bedzie
              w working tree a bez w index
    - Local repository - tu sa plki spakowane w commity

---------------------------------------------------------------------
------------------------------ KOMENDY ------------------------------
---------------------------------------------------------------------

--------------- INFORMACJE ---------------

git status - pokazuje aktualny status naszego repozytorium
          <sciezka do folderu> - pokaze status plików tylko z danego folderu
          > np.     git status src/main/Java/GIT - pokaze status plikow z folderu GIT

git diff - pokazuje roznice w plikach pomiedzy working tree a indexem
        --staged - roznica w plikach pomiedzy idexem a local repozitory
        <commit_number> - pomiedzy working tree a danym commitem
        HEAD - pomiedzy working tree a headem
        <nazwa_pliku> - pokazuje roznice tylko w tym pliku/plikach
        > np.     git diff HEAD File2.js - pokaze roznice w pliku File2 pomiedzy working tree a headem

git show - pokazuje informacje o niepushnietych commitach

git log - pokazuje liste pushnietych commitow (z OBECNEJ gałęzi)
        --graph - pokazuje drzewo z rozgałęzieniami (z OBECNEJ gałęzi)
        --graph --oneline - pokazuje drzewo z rozgalezieniami ale w skróconej wersji (z OBECNEJ gałęzi)
        --all  - pokazuje coś z wszystkich gałęzi
        > np.     git log --graph --oneline --all - pokaze drzewko ze wszystkich commitów

git reflog - pokazuje wszystko to bylo robione na naszym gitowym repo

--------------- DODAWANIE/USUWANIE PLIKU ---------------

git add <nazwa pliku> - dodaje plik/aktualna wersje do indexu
        . - wszystkie pliki
        Mys* - wszystkie pliki zaczynajace sie na Mys
        folder1/folder2/* - wszystkie pliki które znajdują się w folder1 > folder2
        File1.txt File2.txt - doda te dwa pliki (TAB wypelnia nazwy plikow)
        > np.    git add folder1/Mys* - doda wsyztkie pliki zaczynajace sie na Mys z folder1

git add -p <ściezka do pliku> - pozwoli wybrac konkretne linijki ktore zostana dodane do indexu
        //TODO rozkminic potem jak to sie robi. e to edycja ? to pomoc

git commit -m "nazwa commita" - z plików które sa w indexie tworzy commit o podanej nazwie

git reset <sciezka do pliku> - podmienia plil w idexie na ten z najnowszej rewizji (head)

git checkout <commit_number> <sciezka do pliku>  - zastepuje plik w idexie i working tree plikiem z danego commita
        > np.   git checkout c4ds folder1/Pli.txt - podmieni Pli.txt na wersje z commita c4ds...

--------------- OBSLUGA GALEZI ---------------

Wskaznik head to ten na ktorym obecnie jestesmy.
Może on wskazywac na brancha, albo na konkretny commit (lepiej zeby na brancha)
Jesli wskazuje na commit to w git status pojawi sie info "detached HEAD "

Wskaznik branch pokazuje na ostatni commit w danej galezi (jej czubek)

Jeżeli  wprowadzimy jakies zmiany a natepnie bedziemy chcieli przeskoczyc do
danego commita to te zmiany (o ile to mozliwe) będą widoczne commicie do ktorego przeskakujemy
Jeżeli przeniesienie zmian nie bedzie mozliwe to dostaniemy o tym info i przeskok na commit sie nie wykona
Jeżeli mimo to chemy przeskoczyc i straic zmiany to rzeba uzyc parametru --force (usunie zmiay w plikach ale nie pliki!)

    git checkout <identyfikator commita/nazwa brancha>  - przeskoczy do danego brancha i wyrowna pliki z nim
        --force (-f) - wymusza zmiane heada bez wzgledu na to czy zmiany w plikach da sie przeniesc (jesli sie nie da to usuanie)
        head~ - cofa sie o jeden commit w tyl wzgledem aktualnego heada
        master~3 - cofa sie o 3 commity wzgledem mastera
        >np.  git checkout -f master - przeniesie nas na mastera

gdy np piszemy cos na swoim branchu "XD" ale jednak nie chcemy zeby te zmiany wesly i  chcemys ie cofnac do ostatniego commita to
    git checkout -f XD - przeniesie nas do commita, usunie zmiany w plikach ale NIE nieśledzone, nowe pliki
    git clean -nd - sprawdza co nie zostalo usuniete z niesledzonych plikow
    git clean -fd - usuwa to to jest niesledzone

    git branch - wypisze wszystkie branche jakie byly w danym projekcie
               --list <czesc nazwy> - pokaze branche ktore sie zaczynaja od takich nazw
               >np.     git branch --list bug* - pokaze branche ktore zaczynaja sie na bug
               --merged <nazwa brancha> - pokaze wszystkie branche ktore sa domergowane do <nazwa brancha>
               --no-merged <nazwa brancha> - pokaze wszystkie branche ktore NIE sa domergowane do <nazwa brancha>
               -m <stara nazwa> <nowa nazwa> - zmienia nazwe brancha <stara nazwa> na <nowa nazwwa>
               -d <nazwa brancha> - usunie brancha ktory jest domergowany do obecnego heada. jesli nie bedzie rzuci blad
               -D <nazwa brancha> - usunie brancha. jesli nie jest domergowany to pliki z niego usuna sie po 30 dniach

    git reset <identyfikator commita> - wykonywac na commicie ktory ma byc uciety.przerzuci heada i czolowke brancha
        na dany commit. commity ktore sa potem zostana usuniete po 30 dniach. stosowac tylko na commitach ktore nie byly puschniete
                --hard - wyczysci working tree i idex
                --mixed - wyczycsci idex (domyslne)
                --soft - nic nie wyczysci, tylko przeniesie flagi
    git revert <numer commita najnowszego> <numer commita najstrszego> - odwróci zmiany wprowadzone w commitach
        z zakresu <najnowszy><najstarszy> i ZCOMMITUJE JE OD RAZU
                -n <numer commita najnowszego> <numer commita najstrszego> - nie zcommituje ich od razu tylko wejdzie na
                    tryb REVERTING


--------------- GALEZIE  ---------------

- Tworzenie:
    git branch <nazwa_brancha> <identyfikator_comita> - tworzene nowej gałęzi. jesli nie podamy identyikatora to zrobi z heada
WAŻNE! jeśli chcemy zaczac pisac na nowym branchu to trzeba sie na niego przepiąć headem (git checkout <nazwa_brancha>)
Możemy to też zrobić w nastepujący sposob
    git checkout -b <nazwa_brancha> <identyfikator_comita> -tworzene nowej gałęzi i przełączenie sie na nia.
        >np. git checkout -b XD master~3 - storzy brancha XD z 3 commitra przed masterem i przelaczy sie na niego

- Scalanie:
Aby scalic jedna gałąź do drugiej musimy byc headem na tej gałęzi DO której chemy scalić inna (np. git checkout master)\
    git merge <nazwa brancha> - scali brancha <nazwa brancha> do tego  na ktorym obecnie jestesmy headem
        jeżeli bedzie mógł to scali go nie przez commit a po prostu przez przeniesienie flagi.

jesli chemy aby na pewno przeniósł go przez commit (zeby bylo to ladnie widoczne na grafie) to uzuwamy
    git merge --no-ff <nazwa brancha> - wymusi scalanie przez commit

- Konflikty:
Git sprobuje sam sie domyslic ktore pliki gdzie wgrac. jesli nie bedzie mogl tego zrbic to powstanie konflikt
a informacj o nim pojawi sie w terminalu. Wówczas dostaniemy info, ze jestesmy na <nazwa brancha? | MERGING
jest to specyficzny stan sluzacy tylko i wylacznie do obslugi konfliktow

    git merge --abort - anuluje merga gdy jest w trybie MERGING i wychodzi z niego

W przypadku konfliktu w plikach postana markery
    <<<<<<< HEAD (nazwa branacha do ktorego chcemy domergowac)
      zawartość pliku na tym brnchu
    =======
     zawartosc plku na branchu ktory chcemy domergowac
    >>>>>>> fix (nazwa brancha ktory chcemy domergowac)

Po rozwiązaniu konfliktu usuwamy markery, zapisujemy plik, dodajemy do indexu i piszemy komende
    git merge --continue - sprobuje domergowac jeszce raz. jak sie uda wyjdzie z trybu MERGING

W przypadku gdy np na 1 branchu zmienimy cos w pliku,a w a 2 rodzielimy ten plik na 2 inne to w trybie MERGING
bedą widoczne wszystkie 3 pliki.

--------------- ZDALNE REPO ---------------

orgin jest to jakby flaga/informacja ze tyczy sie to zdalnego repo np. orgin/master

    git remote -v - pokazuje na jaki link bedziemy pushowac, i z jakiego linkui fetchowac nasze repo
    git branch -r - pokazuje liste branchy na zdalnym repo i na jakim branchu jest head

    git push - wysyla wsyztskie zmiany na repo z remote -v
            <nazwa repo> <nazwa brancha> - pushuje tylko danego brancha na dane repo
            > np.   git push orgin xd - wysle brancha xd na repo
            >
    git featch - pobiera info o zmianach z repo z remote -v
            <nazwa repo> <nazwa brancha> - sprawdza tylko danego brancha na dane repo
    git pull - pobiera zmiiany z repo z remote -


--------------- GIT IGNORE ---------------

touch .gitignore  - jeśli nie mamy stworzonego pliku .gitignore to nalezy go stworzyc ta komenda
do tego pliku nalezy wpisasc wszytkie pliki które chcemy zignorować
WAŻNE! będzie ignorował tylko pliki które sa w Working tree.
jesli chemy ignorowac pliki z idexu nalezy je najpierw z niego usunac

    output.dll - pojedynczy plik
    *.dll - wszsystkie pliki z rozszerzeniem .dll
    /src/main/java/GIT - wszystkie pliki z folderu GIT


--------------- KONFIGURACJA ---------------

        --global - ustawienia dla danego uzytkownika
        --system - ustawienia dla calego komputera
        --local  - ustawienia dla danego projektu (repo)

    git config <zakres> user.name "<nazwa>"" - ustawia w danym zakresie dana nazwe uzytkownika
    git config <zakres> user.email "<mail> - ustawia w danym zakresie dany email uzytkownika

    git config user.name/email - wyswietli nazwe lub mail

    git config <zakres> alias.<nazwa> "<komenda> (bez git)" - dopisze komende do nazwy przez co latwiej ja wyolaby
        > np.     git config --global alias.iguana "add *" - doda  globalnie komende add * do zmiennej add
        >         git iguana - /\ wywoła powyższa komende
